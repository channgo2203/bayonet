<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Bayonet: bayonet::Bayesnet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bayonet
   </div>
   <div id="projectbrief">C++ library for Bayesian networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bayonet</b></li><li class="navelem"><a class="el" href="classbayonet_1_1_bayesnet.html">Bayesnet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbayonet_1_1_bayesnet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bayonet::Bayesnet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the whole Bayesian network.  
 <a href="classbayonet_1_1_bayesnet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bayesnet_8h_source.html">Bayesnet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5786e74d7f76586eaf6ee2e52a5b626e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a5786e74d7f76586eaf6ee2e52a5b626e">Bayesnet</a> (unsigned int totNodes, unsigned int totStates)</td></tr>
<tr class="separator:a5786e74d7f76586eaf6ee2e52a5b626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc4870f26d4bd00953d7589c2d4abd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a27bc4870f26d4bd00953d7589c2d4abd">Bayesnet</a> (std::vector&lt; unsigned int &gt; nodesTotStatesVector)</td></tr>
<tr class="separator:a27bc4870f26d4bd00953d7589c2d4abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d3ee29b0676789a3c5d1c33a0e36a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#af0d3ee29b0676789a3c5d1c33a0e36a2">~Bayesnet</a> ()</td></tr>
<tr class="separator:af0d3ee29b0676789a3c5d1c33a0e36a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2367ab8e0fdae128f17159f09c63eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbayonet_1_1_bayesnode.html">Bayesnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#ac2367ab8e0fdae128f17159f09c63eea">operator[]</a> (unsigned int index)</td></tr>
<tr class="separator:ac2367ab8e0fdae128f17159f09c63eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba354bf67d39dc73e070e63b9bc45ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#aba354bf67d39dc73e070e63b9bc45ecd">AddEdge</a> (unsigned int FirstNode, unsigned int SecondNode)</td></tr>
<tr class="separator:aba354bf67d39dc73e070e63b9bc45ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea810411a987ebeb97b580053ce7c7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a0ea810411a987ebeb97b580053ce7c7f">RemoveEdge</a> (unsigned int FirstNode, unsigned int SecondNode)</td></tr>
<tr class="separator:a0ea810411a987ebeb97b580053ce7c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae852714069b47eff14918d5a4e53a2dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#ae852714069b47eff14918d5a4e53a2dd">HasEdge</a> (unsigned int FirstNode, unsigned int SecondNode)</td></tr>
<tr class="separator:ae852714069b47eff14918d5a4e53a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d68782e4d08abf2bb2f0ad093db78cc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a2d68782e4d08abf2bb2f0ad093db78cc">ReturnNumberOfNodes</a> ()</td></tr>
<tr class="separator:a2d68782e4d08abf2bb2f0ad093db78cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e6612c84beb2d4e6d5c55792f3ed4e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a42e6612c84beb2d4e6d5c55792f3ed4e">ReturnNumberOfEdges</a> ()</td></tr>
<tr class="separator:a42e6612c84beb2d4e6d5c55792f3ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33076271f03ba59ac98a04b762d26b"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#acb33076271f03ba59ac98a04b762d26b">ReturnOutEdges</a> (unsigned int index)</td></tr>
<tr class="separator:acb33076271f03ba59ac98a04b762d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621b949d8fda17ae0efd9810655b1b3"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a5621b949d8fda17ae0efd9810655b1b3">ReturnInEdges</a> (unsigned int index)</td></tr>
<tr class="separator:a5621b949d8fda17ae0efd9810655b1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9de07f181dc75f309b7f59e302a947"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#aae9de07f181dc75f309b7f59e302a947">ReturnNumberOutEdges</a> (unsigned int index)</td></tr>
<tr class="separator:aae9de07f181dc75f309b7f59e302a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d47ce38f3882b80121f6acc351fd373"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a7d47ce38f3882b80121f6acc351fd373">ReturnNumberInEdges</a> (unsigned int index)</td></tr>
<tr class="separator:a7d47ce38f3882b80121f6acc351fd373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8e924c33186e72bfa7d8ace1c211e6"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a3e8e924c33186e72bfa7d8ace1c211e6">ReturnTopologicalList</a> ()</td></tr>
<tr class="separator:a3e8e924c33186e72bfa7d8ace1c211e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0043ca31c5eb4fe742557bf92cc943a5"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a0043ca31c5eb4fe742557bf92cc943a5">ReturnRootList</a> ()</td></tr>
<tr class="separator:a0043ca31c5eb4fe742557bf92cc943a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30c1485ff84825f534bf7604ee0115d"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#ac30c1485ff84825f534bf7604ee0115d">ReturnLeafList</a> ()</td></tr>
<tr class="separator:ac30c1485ff84825f534bf7604ee0115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05513604bc2273f64abd7e685d1d636"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#af05513604bc2273f64abd7e685d1d636">ReturnTotalStates</a> ()</td></tr>
<tr class="separator:af05513604bc2273f64abd7e685d1d636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f389cd6382946deb5b04cb6513f11e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#ac9f389cd6382946deb5b04cb6513f11e">ReturnNotEvidenceNodes</a> ()</td></tr>
<tr class="separator:ac9f389cd6382946deb5b04cb6513f11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8610f2ec52297edfe6bf2151d2ce002c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a8610f2ec52297edfe6bf2151d2ce002c">ReturnEvidenceNodes</a> ()</td></tr>
<tr class="separator:a8610f2ec52297edfe6bf2151d2ce002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0140ea4f620f852b12746f2a92bd4013"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a0140ea4f620f852b12746f2a92bd4013">GetNodeProbability</a> (unsigned int index, std::vector&lt; unsigned int &gt; variablesStatesVector)</td></tr>
<tr class="separator:a0140ea4f620f852b12746f2a92bd4013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a934ac59da3a02720c40515b6b599e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a2a934ac59da3a02720c40515b6b599e7">ResetAllColours</a> ()</td></tr>
<tr class="separator:a2a934ac59da3a02720c40515b6b599e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceeb50586b7c5c5920e276671d8f30e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#aaceeb50586b7c5c5920e276671d8f30e">IsTree</a> ()</td></tr>
<tr class="separator:aaceeb50586b7c5c5920e276671d8f30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82ed68cc718009c948d681addd48e23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#af82ed68cc718009c948d681addd48e23">IsMultiConnected</a> ()</td></tr>
<tr class="separator:af82ed68cc718009c948d681addd48e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5877478cf225ed47f43df29cc087c5d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a5877478cf225ed47f43df29cc087c5d6">IsRoot</a> (unsigned int)</td></tr>
<tr class="separator:a5877478cf225ed47f43df29cc087c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9809dc12e3f77859f9674ced08fe7b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#af9809dc12e3f77859f9674ced08fe7b0">IsLeaf</a> (unsigned int)</td></tr>
<tr class="separator:af9809dc12e3f77859f9674ced08fe7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b349d82edb61c0c982bb4b1240912da"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbayonet_1_1_bayesnode.html">Bayesnode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a7b349d82edb61c0c982bb4b1240912da">ReturnNodesVector</a> ()</td></tr>
<tr class="separator:a7b349d82edb61c0c982bb4b1240912da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586e4951a91ac2c47d8448caea25d657"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586e4951a91ac2c47d8448caea25d657"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FillJointProbabilityTable</b> ()</td></tr>
<tr class="separator:a586e4951a91ac2c47d8448caea25d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef5210316c514cd50e977d5bc6292e5"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#adef5210316c514cd50e977d5bc6292e5">BreadthFirstSearch</a> (unsigned int startingNode)</td></tr>
<tr class="separator:adef5210316c514cd50e977d5bc6292e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aee3d53ca9a2b534528c53c9813bf"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayonet_1_1_bayesnet.html#a7b1aee3d53ca9a2b534528c53c9813bf">DepthFirstSearch</a> (unsigned int startingNode)</td></tr>
<tr class="separator:a7b1aee3d53ca9a2b534528c53c9813bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents the whole Bayesian network. </p>
<hr/>
 </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5786e74d7f76586eaf6ee2e52a5b626e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bayonet::Bayesnet::Bayesnet </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>totNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>totStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It create a net with a certain number of nodes and number of states. Using this constructor is easy to create very big network without pain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">totNodes</td><td>the number of nodes to store in the network </td></tr>
    <tr><td class="paramname">totStates</td><td>the number of states that each node must have </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27bc4870f26d4bd00953d7589c2d4abd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bayonet::Bayesnet::Bayesnet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>nodesTotStatesVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It create a net with a certain number of nodes and number of states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfNodes</td><td>the number of nodes to add to the network </td></tr>
    <tr><td class="paramname">numberOfStates</td><td>the number of state to assign to each node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d3ee29b0676789a3c5d1c33a0e36a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bayonet::Bayesnet::~Bayesnet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It destroys the object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aba354bf67d39dc73e070e63b9bc45ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::AddEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>secondNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It adds an Edge between two nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstNode</td><td>the parent node </td></tr>
    <tr><td class="paramname">secondNode</td><td>the child node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adef5210316c514cd50e977d5bc6292e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startingNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Breadth First Search algorithm. Starting from a node it performs a breadth-first traversal of the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingNode</td><td>the index of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>it returns a list of index representing the order of nodes visited </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1aee3d53ca9a2b534528c53c9813bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startingNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Depth First Search algorithm. Starting from a node it performs a depth-first traversal of the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingNode</td><td>the index of the node </td></tr>
    <tr><td class="paramname">spToList</td><td>a shared pointer to a list, that is filled recursively by the algorithm. </td></tr>
    <tr><td class="paramname">resetColour</td><td>if true it reset all the colour to white before starting the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0140ea4f620f852b12746f2a92bd4013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bayonet::Bayesnet::GetNodeProbability </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>variablesStatesVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the the index of a variable and the states of all the variables, it returns the associated probability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableState</td><td></td></tr>
    <tr><td class="paramname">parentsStates</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae852714069b47eff14918d5a4e53a2dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::HasEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>secondNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It checks if an Edge between two nodes exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstNode</td><td>the parent node </td></tr>
    <tr><td class="paramname">secondNode</td><td>the child node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9809dc12e3f77859f9674ced08fe7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::IsLeaf </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A leaf node is a node without children but with parents.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns true if the node is a leaf node. </dd></dl>

</div>
</div>
<a class="anchor" id="af82ed68cc718009c948d681addd48e23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::IsMultiConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multi-Connected Bayesian network is a network with multiple possible paths from a starting node to an arriving node. To check if the network is multi- connected, a DepthFirst search is done from the root nodes, during the DFS traversal it is possible to see if some nodes were already visited.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns true if the network is multi-conncted </dd></dl>

</div>
</div>
<a class="anchor" id="a5877478cf225ed47f43df29cc087c5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::IsRoot </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A root node is a node without parents but with children.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns true if the node is a root node. </dd></dl>

</div>
</div>
<a class="anchor" id="aaceeb50586b7c5c5920e276671d8f30e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::IsTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A Bayesian network is a Tree if it has only one root node and no cycles.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns true if the network is a tree </dd></dl>

</div>
</div>
<a class="anchor" id="ac2367ab8e0fdae128f17159f09c63eea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbayonet_1_1_bayesnode.html">Bayesnode</a> &amp; bayonet::Bayesnet::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator overload [] it is used to return thereference to the node stored inside the net It is possible to access the methods of the single node in a easier way. Example: net[2].<a class="el" href="classbayonet_1_1_bayesnet.html#a5877478cf225ed47f43df29cc087c5d6">IsRoot()</a>; // It checks if the third node is a root node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the number of the element stored inside the net </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>it returns a reference to the node </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea810411a987ebeb97b580053ce7c7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bayonet::Bayesnet::RemoveEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>secondNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It removes an Edge between two nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstNode</td><td>the parent node </td></tr>
    <tr><td class="paramname">secondNode</td><td>the child node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a934ac59da3a02720c40515b6b599e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bayonet::Bayesnet::ResetAllColours </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all the nodes colours to white. </p>

</div>
</div>
<a class="anchor" id="a8610f2ec52297edfe6bf2151d2ce002c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; bayonet::Bayesnet::ReturnEvidenceNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns a list containing the index to the nodes which are Evidence nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns the list of evidence node </dd></dl>

</div>
</div>
<a class="anchor" id="a5621b949d8fda17ae0efd9810655b1b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::ReturnInEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns the input index list. </p>

</div>
</div>
<a class="anchor" id="ac30c1485ff84825f534bf7604ee0115d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::ReturnLeafList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I return a list of integers, containing the index of all the Leaf nodes. </p>

</div>
</div>
<a class="anchor" id="a7b349d82edb61c0c982bb4b1240912da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classbayonet_1_1_bayesnode.html">Bayesnode</a> &gt; &amp; bayonet::Bayesnet::ReturnNodesVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It return a const reference to the internal vector used to store the nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns a const reference </dd></dl>

</div>
</div>
<a class="anchor" id="ac9f389cd6382946deb5b04cb6513f11e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; bayonet::Bayesnet::ReturnNotEvidenceNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns a list containing the index to the nodes which are not Evidence nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns the list of not evidence node </dd></dl>

</div>
</div>
<a class="anchor" id="a7d47ce38f3882b80121f6acc351fd373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int bayonet::Bayesnet::ReturnNumberInEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns the number of ingoing edges from the node specified in the index. </p>

</div>
</div>
<a class="anchor" id="a42e6612c84beb2d4e6d5c55792f3ed4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int bayonet::Bayesnet::ReturnNumberOfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns the number of edges. </p>

</div>
</div>
<a class="anchor" id="a2d68782e4d08abf2bb2f0ad093db78cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int bayonet::Bayesnet::ReturnNumberOfNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns the number of nodes. </p>

</div>
</div>
<a class="anchor" id="aae9de07f181dc75f309b7f59e302a947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int bayonet::Bayesnet::ReturnNumberOutEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns the number of Incoming edges from the node specified in the index. </p>

</div>
</div>
<a class="anchor" id="acb33076271f03ba59ac98a04b762d26b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::ReturnOutEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns output index list </p>

</div>
</div>
<a class="anchor" id="a0043ca31c5eb4fe742557bf92cc943a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::ReturnRootList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I return a list of integers, containing the index of all the Root nodes. </p>

</div>
</div>
<a class="anchor" id="a3e8e924c33186e72bfa7d8ace1c211e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; bayonet::Bayesnet::ReturnTopologicalList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The topological sort algorithm creates a linear ordering of the vertices. If edge (u,v) appears in the graph, then u comes before v in the ordering. The topological order is used during the sampling phase for sending queries to a node only when all the parents were already sorted. The algorithm for topological ordering use the DepthFirstSearch function to calculate the finish time of every node. Each node in a DAG goes from a node of higher finish time to a node of lower node finish time. The problem with cyclic graph is due to the fact that back edges go from nodes of lower finish time to nodes of higher finish time</p>
<dl class="section return"><dt>Returns</dt><dd>It returns a list of index to nodes sorted in topological order. </dd></dl>

</div>
</div>
<a class="anchor" id="af05513604bc2273f64abd7e685d1d636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; bayonet::Bayesnet::ReturnTotalStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It returns a list with the total number of states for each node.</p>
<dl class="section return"><dt>Returns</dt><dd>it returns the list of total states </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_bayesnet_8h_source.html">Bayesnet.h</a></li>
<li>src/Bayesnet.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 23 2015 16:37:32 for Bayonet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
